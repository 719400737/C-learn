---
typora-root-url: ./
---

# 高级sql

## 1.mysql框架介绍

关系性数据库

### mysql文件

**1.二进制日志**：主从复制

**2.错误日志**：默认关闭，记录严重的警告和错误信息

**3.查询日志**：默认关闭，记录查询的sql语句，开启会降低性能

**4.数据文件**：

1.库的路径，默认/var/lib/mysql

2.frm文件：存放表结构

3.myd文件：存放表数据

4.myi文件：存放表索引

**5.配置文件**：/etc/my.cnf

### 架构介绍：

![1593957186(1)](/1593957186(1).png)

**插件式的存储引擎架构将查询处理和其他系统任务以及数据的存储提取相分离。**

**1.连接层**：最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端服务端工具实现的类似与tcp/ip的通信，主要完成一些类似于连接处理、授权认证、及相关的安全方案。该层引入线程池的概念，为通过认证安全接入的客户端提供线程。同样该层上可以实现基于SSL的安全链接。

**2.服务层**：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化以及部分内置函数的执行。所有跨存储引擎的功能也在这层实现，如过程、函数。在这层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化，如确定查询表的顺序，是否利用索引等，最后生成相应的操作。如果是select语句服务器还会查询内部缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能很好的提高性能。

**3.引擎层**：存储引擎层，负责mysql中数据的存储和提取，服务器通过API与存储引擎通信，不同的引擎具有不同的功能。

**4.存储层**：将数据存储在运行于裸设备的文件系统上，完成与存储引擎的交互。

### mysql存储引擎

| 对比项   | MyISAM                                             | InnoDB                                                       |
| -------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 主外键   | 不支持                                             | 支持                                                         |
| 事务     | 不支持                                             | 支持                                                         |
| 行表锁   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发 | 行锁，操作时只会锁住某一行，不会对其他行产生影响，**适合高并发操作** |
| 缓存     | 只缓存索引，不缓存真实数据                         | 不仅缓存索引，也缓存数据，对内存要求高，内存大小对性能有决定性影响 |
| 表空间   | 小                                                 | 大                                                           |
| 默认安装 | Y                                                  | Y                                                            |



## 2.索引优化分析

### 1.性能下降SQL慢、执行时间长、等待时间长

| 查询语句写的烂                           |
| ---------------------------------------- |
| 索引失效                                 |
| 关联查询太多join                         |
| 服务器调优及各个参数设置（缓冲、线程等） |

### 2.常见通用的join查询

 ![1593999122(1)](/1593999122(1).png)

**解析从from开始**

**7个join**

### 3.索引简介

#### 索引定义

| 索引定义：索引是帮助MySQL高效获取数据的数据结构---索引是数据结构 |
| ------------------------------------------------------------ |
| <span style=color:red;background:yellow> **简单理解为：排好序的快速查找数据结构**</span> 数据本身外，数据库还维护着一个满足特定查找算法的数据结构，数据结构以某种方式指向数据，这样可以在数据结构的基础上实现高级查找算法，这种数据结构就是索引。 |
| 一般来说索引本身也很大，因此索引往往以索引文件的形式存储在磁盘上 |
| <span style=color:red>我们平时所说的索引一般指B树机构组织的索引</span>，除B+树索引外还有哈希索引 |

#### 索引的优势：

1.提高数据检索效率，降低数据库IO成本。

2.通过索引对数据进行排序，降低排序成本，降低了CPU的消耗。

#### 索引的劣势：

1.索引也是一张表，保存了主键与索引字段，占用空间。

2.提高了查询速度，但是降低了更新表的速度，如insert，update，delete。

3.索引只是一个提高效率的因素，如果有大数据量的表，需要花时间研究建立最优秀的索引。

#### 索引分类

| 单值索引 | 一个索引值包含单个列，一个表可以有多个单列索引 |
| -------- | ---------------------------------------------- |
| 唯一索引 | 索引列的值必须唯一，但允许有空值               |
| 复合索引 | 一个索引包含多个列                             |

基本语法：

| 创建 | create [unique] index in_name on mytable(colname(length));   |
| ---- | ------------------------------------------------------------ |
|      | alter mytable add [unique] index[in_name] on (colname(length)); |
| 删除 | drop index [in_name] on mytable; 删除某个索引                |
| 查看 | show index from table_name\G                                 |

#### 索引结构

B树

#### 那些情况需要建立索引

| 1.主键自动建立唯一索引                                       |
| ------------------------------------------------------------ |
| 2.频繁作为查询条件的字段应该创建索引                         |
| 3.查询中与其他表关联的字段，外键关系建立索引                 |
| 4.频繁更新的字段不适合创建索引                               |
| 5.where条件中用不到的字段不创建索引                          |
| 6.单键/组合索引，在高并发下倾向去创建组合索引                |
| 7.查询中的排序的字段，排序字段若通过索引去访问将大大提高排序速度 |
| 8.查询中统计或者分组字段                                     |

#### 那些情况不需要建立索引

| 1.表记录太少：300w以下                                 |
| ------------------------------------------------------ |
| 2.经常增删改的表                                       |
| 3.某个数据列包含许多重复的内容，建立索引没有太大的效果 |

### 4.性能分析

#### explain是什么

使用explain可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的
SQL语句的，分析你的查询语句或是表结构的性能瓶颈

#### explain能干什么

| 1.表的读取顺序               |
| ---------------------------- |
| 2.数据读取操作的操作类型     |
| 3.那些索引可以使用           |
| 4.那些索引被实际使用         |
| 5.表之间的引用               |
| 6.每张表有多少行倍优化器查询 |

#### 怎么玩

explain+SQL语句

![1594024633(1)](/1594024633(1).png)

**id**

1.如果id相同，执行顺序由上到下

2.如果id不同，如子查询，id的序号会递增，<span style=color:red>id值越大优先级越高，越先被执行</span>

3.既有相同，又有不同，先执行id大的，平级id顺序执行

**select_type**

| 1.SIMPLE       | 简单的select查询，查询中不包含子查询或者UNION                |
| -------------- | ------------------------------------------------------------ |
| 2.PRIMARY      | 查询中若包含任何复杂的子部分，最外层查询则被标记为           |
| 3.SUBQUERY     | 在select获where列表中包含了子查询                            |
| 4.DERIVED      | 在from列表中包含的子查询会被标记DERIVED<br/>MySQL会递归的执行这些子查询，把结果放在临时表里 |
| 5.UNION        | 若第二个select出现在union之后，则被标记为union<br/>若union包含在from子句的子查询中，外层select被标记为derived |
| 6.UNION RESULT | 从union表获取结果的select，合并的结果集                      |

**type**

| system | 表中只有一行记录（等于系统表），这是const类型的特例，平时不会出现 |
| ------ | ------------------------------------------------------------ |
| const  | 通过索引1次就找到了，用户比较primary key或者unique索引，因为只匹配一行数据，所以很快<br/>如将逐渐置于where中，MySQL就能将该查询转换为一个常量 |
| eq_ref | 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描 |
| ref    | 非唯一性索引扫描，返回匹配某个单独值的所有行                 |
| range  | 只检索给定范围的行，使用一个索引来选择行，key列显示使用那个索引<br/>一般在where语句中出现了between、<、>、in等查询<br/>这种扫描比全表扫描要好，因为它只需要开始与索引的某一点，结束与另一点。 |
| index  | index与all的区别为index只便利索引树，比all快，因为索引文件比数据文件小 |
| all    | 将遍历全表以找到匹配的行                                     |

**possible_keys**

显示可能应用在这张表中的索引，一个或多个

查询涉及到的字段上若存在索引，则该索引将被列出，<span style=color:red>但不一定被查询实际使用</span>

**key**

实际使用的索引，若为NULL表示没有使用索引

<span style=color:red>查询中若使用了覆盖索引，则该索引仅出现在key列表中</span>

**ken_len**

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不是精确性的情况下，长度越短越好

其显示的值为索引字段的最大可能长度，<span style= color:red>并非实际使用长度</span>，其是根据表定义计算而得，不是通过表内检索出的。

**ref**

显示索引的哪一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值。

**row**

根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

**Extrea**

（group by和order by要尽量和索引的顺序和数量一致，要不极其易产生文件内排序和临时表，拖慢速度）

覆盖索引：就是select的数据列只从索引中就可以取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<span style= color:red>查询列要被建立的索引覆盖</span>。

| <span style=color:red>1、Using filesort</span>  | 说明mysql会对数据使用一个外部的索引顺序，而不是按照表内索引顺序进行读取。效果比较差 |
| ----------------------------------------------- | ------------------------------------------------------------ |
| <span style=color:red>2、Using temporary</span> | 使用了临时表存放结果，常见于排序order by和分组查询group by，效果更差 |
| <span style=color:red>3、Using index</span>     | 表示相应的select使用了覆盖索引，避免访问了表的数据行，效率不错<br/>如果同时出现using where，表明索引被用来执行索引键值的查找<br/>如果没有出现using where，表明索引用来读取数据而非查找动作 |
| 4、Using where                                  | 使用了where过滤                                              |
| 5、Using join buffer                            | 使用了连接缓存                                               |
| 6、impossible where                             | where子句总是false，不能用来获取任何元组                     |
| 7、select tables optimized away                 | 在没有 GROUPBY子句的情况下，基于索引优化MIN/MAX操作<br/>或者对于MyISAM存储引擎优化COUNT(*)操作，<br/>不必等到执行阶段在计算，查询执行计划生成的阶段即可完成优化 |
| 8、distinct                                     | 优化distinct操作，找到第一个匹配的元组后即停止找同样 值的动作 |

### 5.索引优化

单表优化

两表优化：左连接索引建立在右表上，右连接索引建立在左表上

三表优化：在每个小表上都建立索引，索引组好设置在经常需要查询的字段中。

**结论：**

#### Join语句优化：

**尽可能减少Join中的NestedLoop的循环总次数：<span style=color:red>永远用小结果集驱动大结果集</span>**

**优先优化NestedLoop的内层循环**

**保证join语句中被驱动表上的Join条件字段已经被索引；**

**当无法保证被驱动表的Join条件字段被索引且在内存资源充足的前提下，不要吝惜JoinBuffer的设置**

#### 避免失效：

![2020-07-07 10-40-32屏幕截图](/2020-07-07 10-40-32屏幕截图.png)

**2.最佳左前缀法则**：如果索引了多列，要遵守该法则，<span style=color:red>指的是查询从索引的最左前列开始并且不跳过索引中的列（带头大哥不能丢,中间兄弟不能断）</span>。

**4.存储引擎不能使用索引中范围条件右边的列** ：（范围之后全失效）。

**8.要想索引不失效，like%必须跟右边，要想使用左右两个%，需要使用覆盖索引**（建的索引和查的字段在数量和顺序上完全一致）

## 3.查询截取分析

**总结：**

1.慢查询的开启并捕获

2.explain+慢SQL分析

3.show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况

4.SQL数据库服务器的参数调优

### 查询优化

#### 1.永远小表驱动大表

**in和exists**

当A表的数据集小与B表的数据集时，用exists优于in

exists语法：select  ...  from table where exists (subquery)

该语法：将主查询的数据，放在子查询中做条件验证，根据验证结果来决定主查询的数据结果是否保留。

#### 2.orderby关键字优化

oder by满足两种情况，会使用Index方式排序：1.order by语句使用索引最左前列。2.使用where子句与order by子句条件列组合满足索引最左前列。

提高order by的速度

1.不要使用select ×，a.当query的字段总和小于max_length_for_sort_data 后且排序字段不是text|blob类型会使用单路排序，否则使用多路排序。b.可能会超出sort_buffer容量，会创建tmp进行合并排序，导致多次IO。

**总结**

![2020-07-07 20-14-08屏幕截图](/2020-07-07 20-14-08屏幕截图.png)

#### 3.group by关键字优化

其实质是先排序在分组，遵照索引建的最佳左前缀

where 高于 having，能在where搞定的不要用having

### 慢查询日志

### 批量数据脚本

例：往表里插入1000w条数据

1.建表

2.设置参数log_bin_trust_function_creators

3.创建函数，保证每条数据都不同 create function +名（）return（有返回值）

4.创建存储过程 create procedure +名（in .. out ..）（与函数类似，但无返回值，利用参数的IN，OUT来返回）

5.调度存储过程 call+存储过程名

### show Profile

**是什么：**mysql提供用来分析当前会话中语句执行的资源消耗情况，可以用来SQL调优的测量

其保存最近15次运行结果

**开启功能**：show variables like 'profiiling'  set profiling=on;

**查看结果**：show profile；

**诊断SQL**：show profile cpu,block io for query +SQL数字号码

**常用结论**：1.converting HEAP to MyISAM 查询结果太大，内存不够往磁盘上搬。2.creating tmp table 创建临时表。3.copying to tmp table on disk 把内存中的数据复制到磁盘 危险。4.locked

### 全局查询日志

## 4.锁机制

锁是计算机系统调多个进程或线程并发访问的某一资源的机制。

从对数据操作的类型分：读锁、写所。

从对数据操作的粒度分：表锁、行锁。

### **表锁：偏读**

：偏向MyISAM引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突概率最高，并发度最低。

实例

![2020-07-08 10-45-25屏幕截图](/2020-07-08 10-45-25屏幕截图.png)

![2020-07-08 10-46-08屏幕截图](/2020-07-08 10-46-08屏幕截图.png)

![2020-07-08 10-46-23屏幕截图](/2020-07-08 10-46-23屏幕截图.png)

![2020-07-08 10-56-59屏幕截图](/2020-07-08 10-56-59屏幕截图.png)

![2020-07-08 10-57-28屏幕截图](/2020-07-08 10-57-28屏幕截图.png)



**结论：**

1.对于MyISAM表的读操作（加读锁），不会阻塞其他进程对同意表的读操作，但会阻塞对同一表的写操作，只有当读锁释放以后，才会执行其他进程的写操作。

2.对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放以后，才会执行其他进程的读写操作。

**<span style = color:red>读锁会阻塞写，但是不会阻塞读。而写锁会把读和写都阻塞</span>**。

**分析表锁定**

SQL：show status like 'table%';

结果中有两个状态变量记录，Table_locks_immediate：表示表级锁定的次数，表示可以立即获取锁的查询次数。

Table_locks_waited:出现表级锁定争用而发生等待的次数，此值较高说明存在较严重的表级锁争用情况。

### 行锁：偏写

**事务：由一组SQL语句组成的逻辑处理单元，具有以下4个属性，通常成为事务的ACID属性。**

<span style=color:red>**原子性（Atomicity）**</span>事务是一个原子操作单元，其对数据的执行，要么全部都执行，要么全部都不执行。

**<span style=color:red>一致性（Consistent）</span>**在事务开始和完成时，数据必须保持一致状态，这意味着所有相关的数据规则都必须应用与事务的修改，保持数据的完整性；事务结束后，所有内部数据结构（B树索引或双向链表）也必须都是正确的。

**<span style=color:red>隔离性（Isolation）</span>**数据库系统提供一定的隔离机制，保证事务在不受外部操作影响的“独立”环境执行，意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。

**<span style=color:red>持久性（Durable）</span>**事务完成后，它对数据的修改是永久性的，即使出现系统故障也能保持。

并发事务处理带来的问题：

1.更新丢失。2.脏读：以修改但未提交。3.不可重复读。4.幻读：读到了新增数据。

![2020-07-08 14-46-12屏幕截图](/2020-07-08 14-46-12屏幕截图.png)

当vachar类型建立索引而未使用' '时会导致行锁变表锁。

**间隙锁：**当我们使用范围条件而不是相等条件检索树，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做间隙（GAP）。InnoDB也会对这个间隙加锁，这种锁机制就是所谓的间隙锁。

**危害：**当锁定一个范围键值以后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下会造成很大的危害。

**如何锁定一行：**

begin：

select × form table_name where a=8 for update;  //该句锁定具体某行，其他关于该行的操作会被阻塞，知道锁定行回话commit。

commit;

**分析行锁定**

show status like 'innodb_row_lock%';

Innodb_row_lock_waits 等待总次数

## 5.主从复制

MySQL的复制过程分成3步：

1.master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；

2.slave将master的binary log events拷贝到它的中继日志中（relay log）；

3.slave重做中继日志中的事件，将改变应用到自己的数据库中，MySQL复制是异步串行化的。

